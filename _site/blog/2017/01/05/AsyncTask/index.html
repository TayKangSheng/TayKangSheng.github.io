<!DOCTYPE html>
<html>
  <head>
    <title>AsyncTask – Kang Sheng – Programmer ｜ Buddhist ｜ Traveller</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="AsyncTask is a short form for asynchronous task. AsyncTask allows you to perform asynchronous work on your User Interface. By using AsyncTask, you can run blocking operations in a worker thread and publish the results on the User Interface without having to handle threads and/or handlers. As such, it is a helper class around threads and handlers and provides a proper and easy way of handling background operations with the UI Thread.

" />
    <meta property="og:description" content="AsyncTask is a short form for asynchronous task. AsyncTask allows you to perform asynchronous work on your User Interface. By using AsyncTask, you can run blocking operations in a worker thread and publish the results on the User Interface without having to handle threads and/or handlers. As such, it is a helper class around threads and handlers and provides a proper and easy way of handling background operations with the UI Thread.

" />
    
    <meta name="author" content="Kang Sheng" />

    
    <meta property="og:title" content="AsyncTask" />
    <meta property="twitter:title" content="AsyncTask" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Kang Sheng - Programmer ｜ Buddhist ｜ Traveller" href="/feed.xml" />
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:300" rel="stylesheet">
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="/images/avatar.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Kang Sheng</a></h1>
            <p class="site-description">Programmer ｜ Buddhist ｜ Traveller</p>
          </div>

          <nav>
            <a href="/">Home</a>
            <a href="/blog">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>AsyncTask </h1>
  <div style="font-size: 80%; color: grey"> Categories: 
    <span>
    
      
        <a href="/blog/Android">Android</a> 
      
    
    </span>
  </div>


  <div class="entry">
    <p>AsyncTask is a short form for asynchronous task. AsyncTask allows you to perform asynchronous work on your User Interface. By using AsyncTask, you can run blocking operations in a worker thread and publish the results on the User Interface without having to handle threads and/or handlers. As such, it is a helper class around threads and handlers and provides a proper and easy way of handling background operations with the UI Thread.</p>

<h2 id="why-do-we-need-asynctask">Why do we need AsyncTask?</h2>

<p>Android Applications are run in a single thread called the main thread. This thread is also commonly referred to as the UI Thread. Because of the single thread model, it is vital to the responsiveness of your application’s UI that the UI Thread is not blocked. Therefore, blocking codes in this thread will cause the application’s user interface to “hang” and result in the “Application Not Responding” (ANR) dialog. Not only does the UI becomes not responsive, it causes the entire application to crash.</p>

<p>AsyncTask is not a replacement of Threads and Handlers, but simply a helper class for simple background operations. Threads and Handlers are the traditional ways to run blocking operations in worker threads. However writing threads and handlers can quickly become complicated and also results in less readable codes. This is especially inefficient when the background operations are simple and short. AsyncTask provides a proper and easy way to run simple background operations, and manipulate the UI before, during and after the operation. Hence, if you need to keep threads running for long periods of time, it is recommended you use the various APIs provided by the java.util.concurrent packages such as <a href="https://developer.android.com/reference/java/util/concurrent/Executor.html">Executor</a>, <a href="https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a> and <a href="https://developer.android.com/reference/java/util/concurrent/FutureTask.html">FutureTask</a>.</p>

<h2 id="how-to-create-a-asynctask">How to create a AsyncTask?</h2>

<p>AsyncTask has to be <u><b>subclassed</b></u> in order to be used. In another words, you have to create your own class and extends AsyncTask. You will have the liberty to give a name to this asynchronous task that you will be performing in your application. Please pay extra attention to the rules of using AsyncTask below. AsyncTask is simple to use such that many a times we overlook the rules to abide by when using it. By keeping the rules in mind, it can save you alot of debugging time by knowing the proper way to use AsyncTask.</p>

<h3 id="generics-of-asynctask-params-progress-result">3 Generics of AsyncTask &lt;Params, Progress, Result&gt;</h3>

<p>When you subclass AsyncTask, you will need to declare the generics of 3 variables. These 3 variables are Params, Progress and Results. By defining the generics of these 3 variables, your AsyncTask will know what are the variable types it is working with.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">class</span> <span class="nc">MyTask</span> 
  <span class="kd">extends</span> <span class="n">AsyncTask</span><span class="o">&lt;</span><span class="n">Params</span><span class="o">,</span> <span class="n">Progress</span><span class="o">,</span> <span class="n">Results</span><span class="o">&gt;{</span> <span class="o">...</span> <span class="o">}</span></code></pre></figure>

<ul>
  <li>Params: Params is the type of parameters that is going to be sent to the AsyncTask to be worked on. For example, if your AsyncTask is a task that request information from multiple URLs, then your Params should be the generic URL.</li>
  <li>Progress: Progress is the type of parameters that is going to be published on the UI thread as indicators to Users. For example, if you have a progress bar, and you want to display percentage done, then your Progress should be the generic Integer or Double. If you want to display progress in messages, then Progress should be the generic String.</li>
  <li>Results: Results is the type of parameters that is going to be returned by the background operation. For example, your task returns a JSONObject after calling a REST API in the background operation. Then your Results should be the generic JSONObject. If your task returns a count of the number of results received, then your Results should be the generic Integer.</li>
</ul>

<p>An example of a subclassed AsyncTask that is properly declared is as follows:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">class</span> <span class="nc">DownloadPictures</span> 
  <span class="kd">extends</span> <span class="n">AsyncTask</span><span class="o">&lt;</span><span class="n">URL</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;{</span> <span class="o">...</span> <span class="o">}</span></code></pre></figure>

<p>Note that sometimes some of these variables are not used by the asynchronous task. To mark a type as unused, simple use the type Void.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">class</span> <span class="nc">DownloadPictures</span> 
  <span class="kd">extends</span> <span class="n">AsyncTask</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">,</span> <span class="n">Void</span><span class="o">,</span> <span class="n">Void</span><span class="o">&gt;{</span> <span class="o">...</span> <span class="o">}</span></code></pre></figure>

<h3 id="protected-methods">Protected Methods</h3>

<p>These protected methods provides a proper way of interaction between the AsyncTask and the User Interface. By subclassing AsyncTask, minimally you have to override the method doInBackground(…). More often than not, onPostExecute is also overriden in order to use the results from the asynchronous task.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">class</span> <span class="nc">MyTask</span> 
  <span class="kd">extends</span> <span class="n">AsyncTask</span><span class="o">&lt;</span><span class="n">Params</span><span class="o">,</span> <span class="n">Progress</span><span class="o">,</span> <span class="n">Results</span><span class="o">&gt;{</span> 
    
  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="n">Results</span> <span class="nf">doInBackground</span><span class="o">(</span><span class="n">Params</span><span class="o">...</span> <span class="n">params</span><span class="o">)</span> <span class="o">{</span> 
    <span class="c1">// Blocking logic</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>The methods onPreExecute, onPostExecute, onProgressUpdate and publishProgress run on the UI thread, meaning that it is safe to manipulate the UI in these methods. The method doInBackground runs on a worker thread and therefore is executed in the background and it is not advisable to manipulate the UI in this method.</p>

<h4 id="onpreexecute">onPreExecute()</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPreExecute</span><span class="o">(){</span> 
<span class="o">}</span></code></pre></figure>

<p>This method is invoked right before the task is executed. This method runs on the UI Thread and is normally used as a UI setup for the task. Some examples are displaying the progress bar or changing the button view before executing the task. It tells the user that the task is currently running.</p>

<h4 id="doinbackgroundparams-params">doInBackground(Params… params)</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="n">Results</span> <span class="nf">doInBackground</span><span class="o">(</span><span class="n">Params</span><span class="o">...</span> <span class="n">params</span><span class="o">){</span> 
  <span class="c1">// Blocking logic</span>
<span class="o">}</span></code></pre></figure>

<p>This method is invoked on the worker thread immediately after onPreExecute() finishes executing. This method is where all the blocking logic is written and to be run in a worker thread. As the logic in this step is executed in a separate thread, do not manipulate the UI directly in this method.</p>

<p>The parameters of the AsyncTask is passed into this step as params. The return of this method is passed into the last step of AsyncTask, onPostExectute. Therefore the results of AsyncTask must be return at this step and the results must be of the generic type declared when subclassing the AsyncTask.</p>

<p>Manipulation of the UI can be done through calling the publishProgress method. This provides a way to update your UI such as progress bar or displaying messages. publishProgress is executed on the UI thread and therefore is the proper way to manipulate the UI. Note that publishProgress takes in the generic declared when subclassing the AsyncTask.</p>

<h4 id="publishprogressprogress-progress">publishProgress(Progress… progress)</h4>

<p>This method is called only in the doInBackground method. It provides a way for the method doInBackground to manipulate the UI. By calling publishProgress, the onProgressUpdate is invoked and the parameters that is passed into the publishProgress will be passed into onProgressUpdate.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="n">Results</span> <span class="nf">doInBackground</span><span class="o">(</span><span class="n">Params</span><span class="o">...</span> <span class="n">params</span><span class="o">){</span> 
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="n">publishProgress</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Through using publishProgress, the worker thread can access the UI thread and manipulate the UI safely. Note that the units of progress is the generic declared when subclassing the AsyncTask.</p>

<h4 id="onprogressupdateprogress-progress">onProgressUpdate(Progress… progress)</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onProgressUpdate</span><span class="o">(</span><span class="n">Progress</span><span class="o">...</span> <span class="n">progress</span><span class="o">){</span> 
<span class="o">}</span></code></pre></figure>

<p>onProgressUpdate is invoked after a call to publishProgress is made. The timing of execution of this method after publishProgress is called is undefined. There is no guarantee that it will be called immediately but depends on how the system deals with multithreading.</p>

<p>onProgressUpdate is invoked on the UI thread and is used to display any form of progress in the UI while the background computation is still in progress. For example, to animate and update the progress bar or display messages on the logcat.</p>

<h4 id="onpostexecuteresult-result">onPostExecute(Result result)</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPostExecute</span><span class="o">(</span><span class="n">Result</span> <span class="n">result</span><span class="o">){</span> 
<span class="o">}</span></code></pre></figure>

<p>onPostExecute is invoked immediately after doInBackground finishes executing. This method is executed on the UI thread and is normally used to update the UI to indicate that the asynchronous task has finished execution. For example, to hide the progress bar or change the information on the UI with the newly acquired information.</p>

<h3 id="using-asynctask">Using AsyncTask</h3>

<p>AsyncTask must be subclassed to be used. The subclassed AsyncTask can be a nested class or simply a class on its own. In order to start the AsyncTask, the execute method must be called. The paramaters is passed into the task through the execute method.</p>

<p>This is an example of a nested AsyncTask class in an Android Activity.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">AppCompatActivity</span><span class="o">{</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_main</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">){</span>
    <span class="k">new</span> <span class="nf">DownloadImageTask</span><span class="o">().</span><span class="na">execute</span><span class="o">(</span><span class="s">"http://example.com/image.png"</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">DownloadImageTask</span> <span class="kd">extends</span> <span class="n">AsyncTask</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Void</span><span class="o">,</span> <span class="n">Bitmap</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="cm">/** The system calls this to perform work in
     * the UI thread before doInBackground is executed */</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPreExecute</span><span class="o">(){</span>
      <span class="n">showLoadingDialog</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/** The system calls this to perform work in a 
     * worker thread and delivers it the parameters 
     * given to AsyncTask.execute() */</span>
    <span class="kd">protected</span> <span class="n">Bitmap</span> <span class="nf">doInBackground</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">urls</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nf">loadImageFromNetwork</span><span class="o">(</span><span class="n">urls</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="cm">/** The system calls this to perform work in 
     * the UI thread and delivers the result from 
     * doInBackground() */</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPostExecute</span><span class="o">(</span><span class="n">Bitmap</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">ImageView</span> <span class="n">mImageView</span> <span class="o">=</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">mImageView</span><span class="o">)</span>
      <span class="n">mImageView</span><span class="o">.</span><span class="na">setImageBitmap</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
      <span class="n">hideLoadingDialog</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>This is an example of a AsyncTask class separate from the Android Activity class</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DownloadImageTask</span> <span class="kd">extends</span> <span class="n">AsyncTask</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Void</span><span class="o">,</span> <span class="n">Bitmap</span><span class="o">&gt;</span> <span class="o">{</span>

  <span class="cm">/** The system calls this to perform work in
    * the UI thread before doInBackground is executed */</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPreExecute</span><span class="o">(){</span>
    <span class="n">showLoadingDialog</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="cm">/** The system calls this to perform work in a 
    * worker thread and delivers it the parameters 
    * given to AsyncTask.execute() */</span>
  <span class="kd">protected</span> <span class="n">Bitmap</span> <span class="nf">doInBackground</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">urls</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">loadImageFromNetwork</span><span class="o">(</span><span class="n">urls</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
  <span class="o">}</span>

  <span class="cm">/** The system calls this to perform work in 
    * the UI thread and delivers the result from 
    * doInBackground() */</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPostExecute</span><span class="o">(</span><span class="n">Bitmap</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ImageView</span> <span class="n">mImageView</span> <span class="o">=</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">mImageView</span><span class="o">)</span>
    <span class="n">mImageView</span><span class="o">.</span><span class="na">setImageBitmap</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
    <span class="n">hideLoadingDialog</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">AppCompatActivity</span><span class="o">{</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_main</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">){</span>
    <span class="k">new</span> <span class="nf">DownloadImageTask</span><span class="o">().</span><span class="na">execute</span><span class="o">(</span><span class="s">"http://example.com/image.png"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Both methods are viable and provides neat and readable codes. Note that AsyncTask <b><u>MUST</u></b> be executed in the UI thread; in another words, in the Activity or Fragment class.</p>

<p>Refer to the rules below for more rules to abide by in order for AsyncTask to work properly.</p>

<h3 id="cancelling-asynctask">Cancelling AsyncTask,</h3>

<p>An AsyncTask can be cancelled by calling the cancel(boolean) method after execute(params…) method is called. After invoking cancel(boolean), subsequent calls to isCancelled() will return true.</p>

<p>If cancel(boolean) method is called, the onCancelled(Results) method is invoked instead of onPostExecute(Results). Therefore the onCancelled(Results) is only invoked after doInBackground has finished executing. In order to cancel the AsyncTask as soon as possible after cancel(boolean) is called, you should always check the return value of isCancelled() in doInBackground method. The moment isCancelled() returns true, return the method and onCancelled(Results) is invoked right after.</p>

<p>Calling cancel(boolean) will fail if the task has already completed, already been cancelled, or could not be cancelled for some other reasons. If the task is successfully cancelled and the task has not started, then the task should never run. If the task has already started, then whether the worker thread running the background logic can be interrupted will depend on the boolean parameter passed into the method.</p>

<p>The boolean parameter in cancel(boolean) is a flag for “mayInterruptIfRunning”. In simple terms, it means that if mayInterruptIfRunning is true; the task will be interrupted and cancelled if cancel is called when the task is running. If mayInterruptIfRunning is false; the task will not be interrupted and cancelled if cancel is called when the task is running.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">AppCompatActivity</span><span class="o">{</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_main</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">){</span>
    <span class="k">new</span> <span class="nf">DownloadImageTask</span><span class="o">().</span><span class="na">execute</span><span class="o">(</span><span class="s">"http://example.com/image.png"</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">DownloadImageTask</span> <span class="kd">extends</span> <span class="n">AsyncTask</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Void</span><span class="o">,</span> <span class="n">Bitmap</span><span class="o">&gt;</span> <span class="o">{</span>    
    <span class="o">...</span>
    <span class="kd">protected</span> <span class="n">Bitmap</span> <span class="nf">doInBackground</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">urls</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nf">loadImageFromNetwork</span><span class="o">(</span><span class="n">urls</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPostExecute</span><span class="o">(</span><span class="n">Bitmap</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">ImageView</span> <span class="n">mImageView</span> <span class="o">=</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">mImageView</span><span class="o">)</span>
      <span class="n">mImageView</span><span class="o">.</span><span class="na">setImageBitmap</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
      <span class="n">hideLoadingDialog</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCancelled</span><span class="o">(</span><span class="n">Bitmap</span> <span class="n">result</span><span class="o">){</span>
      <span class="n">hideLoadingDialog</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h3 id="threading-rules-of-using-asynctask">Threading rules of using AsyncTask</h3>

<p>The following rules should be abided to guarantee the class to work as expected.</p>

<ol>
  <li>AsyncTask instance must be created on the UI Thread.</li>
  <li>execute(Params… params) must be invoked on the UI Thread.</li>
  <li>Do not call any of the protected methods manually.</li>
  <li>The task can only be executed once. If execute is called subsequent times, an exception will be thrown.</li>
  <li>Starting with HONEYCOMB, all AsyncTask instances are executed on a single worker thread. If parallel execution of the instances are required, use executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>AsyncTask is a simple helper class for running background operations. Tasks should generally be shortlived and once off. If there is a need for long running worker threads, Threads and Handlers should be used instead. The methods in AsyncTask class are guaranteed to be synchronised and one method will be called once at a time.</p>

<p>By using AsyncTask, we can write clean and readable codes and not fall into the complexity of Threads/Handlers or Thread safety in an Android Application.</p>

<h2 id="reference">Reference</h2>
<ol>
  <li>https://developer.android.com/reference/android/os/AsyncTask.html</li>
  <li>https://developer.android.com/guide/components/processes-and-threads.html</li>
</ol>


  </div>

    <div class="date">
       Written on January  5, 2017
    </div>

  
  
    
  
  
  <hr>
  
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'taykangsheng';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

  

</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:kangsheng@gmail.com"><i class="svg-icon email"></i></a>
<a href="https://www.facebook.com/TayKangSheng"><i class="svg-icon facebook"></i></a>

<a href="https://github.com/TayKangSheng"><i class="svg-icon github"></i></a>
<a href="https://instagram.com/kangsterchikenzster"><i class="svg-icon instagram"></i></a>



<a href="https://www.twitter.com/TayKangSheng"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  </body>
</html>
