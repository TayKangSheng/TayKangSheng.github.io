<!DOCTYPE html>
<html>
  <head>
    <title>Merge Sort – Kang Sheng – Programmer ｜ Buddhist ｜ Traveller</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="Merge sort is a classic example of how the concept Divide and Conquer can improve the run time of your algorithm. Sorting can become a complex problem when you have a huge data set and you dont have all the time in the world to let your machine slowly sort the list. Therefore great minds along the years have come up with many sorting methods such as insertion sort, quick sort, counting sort, radix sort and the list goes on and on.

" />
    <meta property="og:description" content="Merge sort is a classic example of how the concept Divide and Conquer can improve the run time of your algorithm. Sorting can become a complex problem when you have a huge data set and you dont have all the time in the world to let your machine slowly sort the list. Therefore great minds along the years have come up with many sorting methods such as insertion sort, quick sort, counting sort, radix sort and the list goes on and on.

" />
    
    <meta name="author" content="Kang Sheng" />

    
    <meta property="og:title" content="Merge Sort" />
    <meta property="twitter:title" content="Merge Sort" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Kang Sheng - Programmer ｜ Buddhist ｜ Traveller" href="/feed.xml" />
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:300" rel="stylesheet">
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="/images/avatar.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Kang Sheng</a></h1>
            <p class="site-description">Programmer ｜ Buddhist ｜ Traveller</p>
          </div>

          <nav>
            <a href="/">Home</a>
            <a href="/blog">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Merge Sort </h1>
  <div style="font-size: 80%; color: grey"> Categories: 
    <span>
    
      
        <a href="/blog/Programming">Programming</a> 
      
    
    </span>
  </div>


  <div class="entry">
    <p>Merge sort is a classic example of how the concept Divide and Conquer can improve the run time of your algorithm. Sorting can become a complex problem when you have a huge data set and you dont have all the time in the world to let your machine slowly sort the list. Therefore great minds along the years have come up with many sorting methods such as insertion sort, quick sort, counting sort, radix sort and the list goes on and on.</p>

<p>In the comparison models for sorting, we have sorting methods such as insertion sort and merge sort where it some point in the algorithm, we always have one main object compared to the others. Comparision sort have a fundamental requirement of O(n log n), and one such algorithm is Merge Sort, which we are going to discuss in this article.</p>

<h2 id="complexity">Complexity</h2>

<p>There are three parts in the Divide and Conquer approach. Note that Divide and Conquer is a recursive approach and that the 3 parts are recursively done to break down the problem into further subproblems.</p>

<ol>
  <li><strong>Divide</strong>. We first have to divide the problem into sub problems. Therefore dividing an array of size n into 2 subarrays of size (n/2).</li>
  <li><strong>Conquer</strong>. In this step, we sort each of the subarrays in itself.</li>
  <li><strong>Merge</strong>. In order to merge the sorted subarrays, we interatively compare the first elements of the subarrays and put them into one array.</li>
</ol>

<p>So how does Merge Sort runs in O(n log n)?</p>

<h4 id="divide-and-merge-steps">Divide and Merge steps</h4>

<p>In order to divide the array into 2 subarrays, we have to intialise 2 subarrays of size n/2. Then iterate through the entire array and clone the first half into the first subarray and the second half into the second subarray. In this step, every division takes O(n) steps.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">T</span><span class="o">[][]</span> <span class="nf">divide</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">toDivide</span><span class="o">){</span>
  <span class="n">T</span><span class="o">[]</span> <span class="n">toSort1</span> <span class="o">=</span> <span class="o">(</span><span class="n">T</span><span class="o">[])</span> <span class="k">new</span> <span class="n">Comparable</span><span class="o">[</span><span class="n">toDivide</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">];</span>
  <span class="n">T</span><span class="o">[]</span> <span class="n">toSort2</span> <span class="o">=</span> <span class="o">(</span><span class="n">T</span><span class="o">[])</span> <span class="k">new</span> <span class="n">Comparable</span><span class="o">[</span><span class="n">toDivide</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">toSort1</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">toSort1</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="n">toSort1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">toDivide</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
  <span class="o">}</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">toSort2</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="n">toSort2</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">toDivide</span><span class="o">[</span><span class="n">toSort1</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="n">i</span><span class="o">];</span>
  <span class="o">}</span>
	
  <span class="n">T</span><span class="o">[][]</span> <span class="n">divided</span> <span class="o">=</span> <span class="o">(</span><span class="n">T</span><span class="o">[][])</span> <span class="k">new</span> <span class="n">Comparable</span><span class="o">[</span><span class="mi">2</span><span class="o">][];</span>
  <span class="n">divided</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">toSort1</span><span class="o">;</span>
  <span class="n">divided</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">toSort2</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">divided</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>Merging subarrays also take on similar approach. We have to interate through both of the sorted subarrays. Since the subarrays are already sorted, we can simply compare the first of both subarrays and put them into one single merged array. Therefore every merge also takes O(n) steps.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">T</span><span class="o">[]</span> <span class="nf">merge</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">toMerge1</span><span class="o">,</span> <span class="n">T</span><span class="o">[]</span> <span class="n">toMerge2</span><span class="o">){</span>
  <span class="n">T</span><span class="o">[]</span> <span class="n">toSort1</span> <span class="o">=</span> <span class="n">toMerge1</span><span class="o">;</span>
  <span class="n">T</span><span class="o">[]</span> <span class="n">toSort2</span> <span class="o">=</span> <span class="n">toMerge2</span><span class="o">;</span>
  <span class="n">T</span><span class="o">[]</span> <span class="n">toMerge</span> <span class="o">=</span> <span class="o">(</span><span class="n">T</span><span class="o">[])</span> <span class="k">new</span> <span class="n">Comparable</span><span class="o">[</span><span class="n">toMerge1</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="n">toMerge2</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
	
  <span class="kt">int</span><span class="o">[]</span> <span class="n">indexes</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">toMerge</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="k">if</span> <span class="o">(</span> <span class="n">indexes</span><span class="o">[</span><span class="mi">0</span><span class="o">]&gt;</span><span class="n">toSort1</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">){</span>
      <span class="n">toMerge</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">toSort2</span><span class="o">[</span><span class="n">indexes</span><span class="o">[</span><span class="mi">1</span><span class="o">]];</span>
      <span class="n">indexes</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">[</span><span class="mi">1</span><span class="o">]+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span> <span class="n">indexes</span><span class="o">[</span><span class="mi">1</span><span class="o">]&gt;</span><span class="n">toSort2</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">){</span>
      <span class="n">toMerge</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">toSort1</span><span class="o">[</span><span class="n">indexes</span><span class="o">[</span><span class="mi">0</span><span class="o">]];</span>
      <span class="n">indexes</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">[</span><span class="mi">0</span><span class="o">]+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span><span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span> <span class="n">compare</span><span class="o">(</span><span class="n">toSort1</span><span class="o">[</span><span class="n">indexes</span><span class="o">[</span><span class="mi">0</span><span class="o">]],</span> <span class="n">toSort2</span><span class="o">[</span><span class="n">indexes</span><span class="o">[</span><span class="mi">1</span><span class="o">]])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
        <span class="n">toMerge</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">toSort1</span><span class="o">[</span><span class="n">indexes</span><span class="o">[</span><span class="mi">0</span><span class="o">]];</span>
        <span class="n">indexes</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">[</span><span class="mi">0</span><span class="o">]+</span><span class="mi">1</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">toMerge</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">toSort2</span><span class="o">[</span><span class="n">indexes</span><span class="o">[</span><span class="mi">1</span><span class="o">]];</span>
        <span class="n">indexes</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">[</span><span class="mi">1</span><span class="o">]+</span><span class="mi">1</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">toMerge</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>Putting together the steps taken to divide and merge, we can assume that it takes O(cn) steps, where c is a constant &gt; 0.</p>

<h4 id="recursively-conquer">Recursively conquer</h4>

<p>We first start from sorting the initial problem. Assuming the time taken for sorting an array of size n takes T(n) time and the time taken to sort an array of size n/2 is T(n/2) and so on and so forth. Eventually we will have n numbers of array of size 1. Naturally if the size of the array is 1, there is no need to sort an array of this size and the number of steps is O(1)</p>

<p><img src="/images/2016-12-1-Subproblems.png" alt="Recursive conquer" class="center-image" /></p>

<h4 id="calculating-complexity">Calculating Complexity</h4>

<p>The total steps taken to actually sort the array comes from the dividing and merging steps. So whats left is figuring the total steps taken from dividing and merging the arrays at each level. If dividing and merging an array of size n takes cn steps, dividing and merging an array of size n/2 takes cn/2 steps. However 1 array of size n results in 2 array of size n/2, and therefore 2 array of size n/2 takes 2*cn/2 steps which results back to cn steps. If we continuing examining the levels downwards, every level will total up to cn steps.</p>

<p><img src="/images/2016-12-1-TimeComplexity.png" alt="Recursive conquer" class="center-image" /></p>

<p>By virtue of dividing the problem into 2 at every level, there will be a total of log n levels of cn step size. Therefore the complexity of solving this problem is O(n log n)</p>

<h2 id="implementation">Implementation</h2>

<p>After we have implemented the divide and merge methods, the main sorting method is fairly straightforward. We just have to recursively split the array into subarrays and call the sort method on each of them. After that, merge the results and we can return the sorted array.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">T</span><span class="o">[]</span> <span class="nf">sort</span><span class="o">(){</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">sort</span><span class="o">(</span><span class="n">array</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">array</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="n">T</span><span class="o">[]</span> <span class="nf">sort</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">toSort</span><span class="o">){</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">toSort</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">){</span>
    <span class="c1">// base case</span>
    <span class="k">return</span> <span class="n">toSort</span><span class="o">;</span>
  <span class="o">}</span>
	
  <span class="n">T</span><span class="o">[][]</span> <span class="n">divide</span> <span class="o">=</span> <span class="n">divide</span><span class="o">(</span><span class="n">toSort</span><span class="o">);</span>
  <span class="n">divide</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">sort</span><span class="o">(</span><span class="n">divide</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span> 
  <span class="n">divide</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">sort</span><span class="o">(</span><span class="n">divide</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>		
  <span class="n">toSort</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">divide</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">divide</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>

  <span class="k">return</span> <span class="n">toSort</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h2 id="conclusion">Conclusion</h2>

<p>Merge sort is a straightforward implementation. It can be very helpful if you need a fairly efficient sorting method quickly implemented. This sorting method can also be easily extended to all data types as long as there is a method of comparison between the data types. My full implementation can be found <a href="/downloads/2016-12-1-MergeSort.java">HERE</a>.</p>

<h2 id="references">References</h2>

<ol>
  <li><a href="https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/analysis-of-merge-sort">https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/analysis-of-merge-sort</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm">https://en.wikipedia.org/wiki/Sorting_algorithm</a></li>
</ol>


  </div>

    <div class="date">
       Written on December  1, 2016
    </div>

  
  
    
      <h3>Related post</h3>
      
        
        
      
        
          <div>
            <h5><a href="/blog/2016/11/29/AVL-Tree/">AVL Tree</a></h5>
          </div>
          
    
  
  
  <hr>
  
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'taykangsheng';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

  

</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:kangsheng@gmail.com"><i class="svg-icon email"></i></a>
<a href="https://www.facebook.com/TayKangSheng"><i class="svg-icon facebook"></i></a>

<a href="https://github.com/TayKangSheng"><i class="svg-icon github"></i></a>
<a href="https://instagram.com/kangsterchikenzster"><i class="svg-icon instagram"></i></a>



<a href="https://www.twitter.com/TayKangSheng"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  </body>
</html>
