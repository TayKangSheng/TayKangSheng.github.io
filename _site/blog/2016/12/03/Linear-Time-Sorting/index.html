<!DOCTYPE html>
<html>
  <head>
    <title>Linear Time Sorting – Kang Sheng – Programmer ｜ Buddhist ｜ Traveller</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="The usual sorting methods always comprises of comparisons between a[i] and a[j] where a[i] and a[j] are elements of the array to be sorted. Such sorting methods are called comparison sort. Some common examples of such sorting methods are MergeSort, QuickSort and HeapSort. Every comparison based sorting algorithm takes Ω(n log n) on average and cannot be faster than that. Note that we are not making any claims about “good” instances as such instances are for example sorted list where sorting might even take linear time.

" />
    <meta property="og:description" content="The usual sorting methods always comprises of comparisons between a[i] and a[j] where a[i] and a[j] are elements of the array to be sorted. Such sorting methods are called comparison sort. Some common examples of such sorting methods are MergeSort, QuickSort and HeapSort. Every comparison based sorting algorithm takes Ω(n log n) on average and cannot be faster than that. Note that we are not making any claims about “good” instances as such instances are for example sorted list where sorting might even take linear time.

" />
    
    <meta name="author" content="Kang Sheng" />

    
    <meta property="og:title" content="Linear Time Sorting" />
    <meta property="twitter:title" content="Linear Time Sorting" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Kang Sheng - Programmer ｜ Buddhist ｜ Traveller" href="/feed.xml" />
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:300" rel="stylesheet">
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="/images/avatar.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Kang Sheng</a></h1>
            <p class="site-description">Programmer ｜ Buddhist ｜ Traveller</p>
          </div>

          <nav>
            <a href="/">Home</a>
            <a href="/blog">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Linear Time Sorting </h1>
  <div style="font-size: 80%; color: grey"> Categories: 
    <span>
    
      
        <a href="/blog/Programming">Programming</a> 
      
    
    </span>
  </div>


  <div class="entry">
    <p>The usual sorting methods always comprises of comparisons between a[i] and a[j] where a[i] and a[j] are elements of the array to be sorted. Such sorting methods are called comparison sort. Some common examples of such sorting methods are MergeSort, QuickSort and HeapSort. Every comparison based sorting algorithm takes Ω(n log n) on average and cannot be faster than that. Note that we are not making any claims about “good” instances as such instances are for example sorted list where sorting might even take linear time.</p>

<p>In this article, we are going to discuss faster sorting algorithms that takes linear time. Specifically, we are going to discuss Counting Sort (a more streamlined version of Bucket Sort) and Radix Sort. We will be going through its logic and implementation. <strong>All sorting implementations in this article are for keys of decimal integers</strong>. After knowing the logic, one can expand the sorting methodologies for other key types.</p>

<h2 id="counting-sort">Counting Sort</h2>

<p>Counting sort is a sorting algorithm that works best where the number of unique keys are not significantly large. As there are no need to sort unique keys as they are of similar values, keys of the same value are dropped into buckets and combined at the end.</p>

<p>The steps are as follows:</p>

<ol>
  <li>Create a histogram of the frequency of each unique key.</li>
  <li>Use arithmetic on the histogram to determine the starting/ending positions of each bucket.</li>
  <li>Put all keys into their respective positions.</li>
</ol>

<p>Implementation of counting sort is simple and straight forward.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">countingSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">toSort</span><span class="o">){</span>
  <span class="c1">// Count the number of buckets </span>
  <span class="c1">// (aka the number of different keys)</span>
  <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">toSort</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">toSort</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">toSort</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">){</span>
      <span class="n">max</span> <span class="o">=</span> <span class="n">toSort</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">// To account for that the key 0 is also a key.</span>
  <span class="n">max</span><span class="o">+=</span><span class="mi">1</span><span class="o">;</span> 
	
  <span class="c1">// this array keeps count of the size of each bucket</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">max</span><span class="o">];</span> 
	
  <span class="c1">// determine how big each bucket should be.</span>
  <span class="c1">// (aka histogram of the frequencies)</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">toSort</span><span class="o">){</span>
    <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span>
  <span class="o">}</span>
	
  <span class="c1">// determine the ending index of each bucket</span>
  <span class="c1">// on a single array. (aka offset)</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]+=</span><span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
  <span class="o">}</span>
	
  <span class="c1">// input each entry into a single array at the ending index </span>
  <span class="c1">// of its bucket and minus the ending index by 1</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">tempArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">toSort</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">toSort</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
    <span class="n">tempArray</span><span class="o">[--</span><span class="n">count</span><span class="o">[</span><span class="n">toSort</span><span class="o">[</span><span class="n">i</span><span class="o">]]]</span> <span class="o">=</span> <span class="n">toSort</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">tempArray</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>Counting Sort uses a methodology more similar towards hashing by using the key values to determine the indexes in the array. Therefore unlike to comparison sorts, there is no repetitive comparison to determine the indexes of key values in the array.</p>

<p>The <strong>time complexity</strong> of this sorting method is O(n + k), where n is the number of keys in the array and k is the number of unique keys. The first for loop to find the maximum number, second for loop to create the histogram of the frequencies and the last for loop where each element is placed in its sorted index takes O(n) time. The thrid for loop loops through the list of unique keys takes O(k) time. Therefore the running time in total for Counting Sort is O(n + k).</p>

<p>Bucket Sort is generally similar to Counting sort both in implementation and time analysis, just that bucket sort requires link list and dynamic arrays or a large amount of preallocated memory to hold the sets of items within each bucket, whereas counting sort stores a single value in each bucket, which is the frequency.</p>

<h2 id="radix-sort">Radix Sort</h2>

<p>So what if we have a significantly large amount of keys and risk setting up millions of buckets where most buckets will stay empty? Radix Sort is an extension of Counting/Bucket sort where we sort the keys iteratively through the significant digits of the value.</p>

<p>Lets consider keys of this form:</p>

<figure class="highlight"><pre><code class="language-none" data-lang="none">d[k-1]d[k-2]....d[2]d[1]d[0]
where 0 &lt;= d[i] &lt; B for some base B
and 	d[k-1] is the Most Significant Digit,
	d[0] is the Least Significant Digit</code></pre></figure>

<p>There are 2 basic approach to Radix Sort. The first is called the Least Significant Digit Radix Sort where we sort the elements by their least significant digit first, and slowly move up the ranks to the most significant digit. The second is called the Most Significant Digit Radix Sort where we sort the elements by their most significant digit first and slowly move down the ranks to the least significant digit. While sorting the keys at a signicant digit, the process is same or a variation of counting sort.</p>

<h4 id="least-significant-digit-radix-sort">Least Significant Digit Radix Sort</h4>

<p>As mention above, the Least Significant Digit Radix Sort sorts the keys by their least significant digit first and slowly move up the ranks to the most significant digit. The algorithm can be done recursively or non-recursively.</p>

<p>The recursive algorithm is as follows:</p>

<figure class="highlight"><pre><code class="language-none" data-lang="none">int[] toSort;
For i = 0..k where k is the number of digits:
  Sort toSort on i-th digit</code></pre></figure>

<p>We first have to implement the counting sort on single digits.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">LSDbucketSortOnDigit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">toSort</span><span class="o">,</span> <span class="kt">int</span> <span class="n">digit</span><span class="o">){</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">tempArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">toSort</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
	
  <span class="c1">// determine how big each bucket should be.</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">toSort</span><span class="o">){</span>
    <span class="n">count</span><span class="o">[</span><span class="n">getNthDigit</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="n">digit</span><span class="o">+</span><span class="mi">1</span><span class="o">)]++;</span>
  <span class="o">}</span>
  <span class="c1">// determine the ending index of each bucket</span>
  <span class="c1">// on a single array. (aka offset)</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]+=</span><span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
  <span class="o">}</span>
  <span class="c1">// input each entry into a single array at the ending index </span>
  <span class="c1">// of its bucket and minus the ending index by 1</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">toSort</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
    <span class="n">tempArray</span><span class="o">[--</span><span class="n">count</span><span class="o">[</span><span class="n">getNthDigit</span><span class="o">(</span><span class="n">toSort</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">10</span><span class="o">,</span> <span class="n">digit</span><span class="o">+</span><span class="mi">1</span><span class="o">)]]</span> <span class="o">=</span> <span class="n">toSort</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">tempArray</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>After implementing counting sort by each digit, the Least Significant Digit Radix Sort is simple to implement.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">radixSort_LSD</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">toSort</span><span class="o">){</span>
  <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">toSort</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">toSort</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">){</span>
      <span class="n">max</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="nf">radixSort_LSD</span><span class="o">(</span><span class="n">toSort</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">max</span><span class="o">).</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">radixSort_LSD</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">toSort</span><span class="o">,</span> <span class="kt">int</span> <span class="n">digit</span><span class="o">){</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">digit</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
    <span class="k">return</span> <span class="nf">LSDcountingSortOnDigit</span><span class="o">(</span><span class="n">toSort</span><span class="o">,</span> <span class="n">digit</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">toSort</span> <span class="o">=</span> <span class="n">radixSort_LSD</span><span class="o">(</span><span class="n">toSort</span><span class="o">,</span> <span class="n">digit</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="k">return</span> <span class="nf">LSDcountingSortOnDigit</span><span class="o">(</span><span class="n">toSort</span><span class="o">,</span> <span class="n">digit</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="most-significant-digit-radix-sort">Most Significant Digit Radix Sort</h4>

<p>For the Most Significant Digit Radix Sort, although the idea is similar to the Least Significant Digit Radix Sort, however there are some underlying complexities.</p>

<p>The recursive algorithm is as follows:</p>

<figure class="highlight"><pre><code class="language-none" data-lang="none">int[] toSort;
sort toSort on k-th digit:
  if k==0:
    return sort toSort on 0-th digit;
  else:
    sort toSort on k-th array into individual arrays
    for each array:
      sort toSort on (k-1)-th array into individual arrays
    return concat (all arrays)</code></pre></figure>

<p>After sorting on a single digit, we need to recursively sort each of these groups on the next digit. If we implement the same method as the Least Significant Digit Radix Sort where we sort on a single digit and sort the entire array on the next most significant digit, the end results will only be a jumbled array where the array is sorted on the least significant digit. Hence there is a need to sort each group by themselves and concatenate the results together.</p>

<p>Therefore, the sorting on a single digit for the Most Signicant Radix Sort is slightly different such that the results should not be combined into a single array. In this way, we can apply the sort on the next most significant digit on the individual arrays.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">MSDcountingSortOnDigit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">toSort</span><span class="o">,</span> <span class="kt">int</span> <span class="n">digit</span><span class="o">){</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
  <span class="kt">int</span><span class="o">[][]</span> <span class="n">tempArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">][];</span>
  <span class="c1">// determine how big each bucket should be.</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">toSort</span><span class="o">){</span>
    <span class="n">count</span><span class="o">[</span><span class="n">getNthDigit</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="n">digit</span><span class="o">+</span><span class="mi">1</span><span class="o">)]++;</span>
  <span class="o">}</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="n">tempArray</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
  <span class="o">}</span>
  <span class="c1">// input each entry into a single array at the ending index </span>
  <span class="c1">// of its bucket and minus the ending index by 1</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">toSort</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
    <span class="kt">int</span> <span class="n">temp_digit</span> <span class="o">=</span> <span class="n">getNthDigit</span><span class="o">(</span><span class="n">toSort</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">10</span><span class="o">,</span> <span class="n">digit</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">tempArray</span><span class="o">[</span><span class="n">temp_digit</span><span class="o">][--</span><span class="n">count</span><span class="o">[</span><span class="n">temp_digit</span><span class="o">]]</span> <span class="o">=</span> <span class="n">toSort</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">tempArray</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>As with the case of the Least Significant Radix Sort, after implementing the single digit counting sort, the rest is straight forward. The Most Significant Radix Sort is a forward recursion.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">radixSort_MSD</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">toSort</span><span class="o">){</span>
  <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">toSort</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">toSort</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">){</span>
      <span class="n">max</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="nf">radixSort_MSD</span><span class="o">(</span><span class="n">toSort</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">max</span><span class="o">).</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">radixSort_MSD</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">toSort</span><span class="o">,</span> <span class="kt">int</span> <span class="n">digit</span><span class="o">){</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">digit</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">temp_array</span> <span class="o">=</span> <span class="n">MSDcountingSortOnDigit</span><span class="o">(</span><span class="n">toSort</span><span class="o">,</span> <span class="n">digit</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">temp_array</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++</span> <span class="o">){</span>
      <span class="n">temp_array</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">concat</span><span class="o">(</span><span class="n">temp_array</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">temp_array</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">temp_array</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">temp_array</span> <span class="o">=</span> <span class="n">MSDcountingSortOnDigit</span><span class="o">(</span><span class="n">toSort</span><span class="o">,</span> <span class="n">digit</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">temp_array</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
      <span class="n">temp_array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">radixSort_MSD</span><span class="o">(</span><span class="n">temp_array</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">digit</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">temp_array</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++</span> <span class="o">){</span>
      <span class="n">temp_array</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">concat</span><span class="o">(</span><span class="n">temp_array</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">temp_array</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">temp_array</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Radix Sort is a expanded version of the counting sort or bucket sort, where the sort is iterated over multiple digits. Radix Sort is also a non-comparison sorting methodology, however unlike counting sort and bucket sort, there should be a fix amount of keys across all digits. For example in decimal, in every digit the number can only be from 0 to 1. Another example is in alphabetical words, in every digit the letters can only be from a-z and A-Z.</p>

<p>The Most Significant Digit Radix Sort can be used to sort keys into lexicographic order and that unlike the Least Significant Digit Radix Sort, it does not necessarily preserve the original order of duplicate keys.</p>

<p>Radix Sort takes O(wn) time to run, where w is the number of digits and n is the number of elements. In both the Most Significant and Least Significant Digit Radix Sort, we will eventually go through all elements at each digit.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The 2 sorts mentioned above generally runs faster than the comparison sorts that runs on O(n log n) time. Counting sort runs at O(n+k) time and Radix sort runs at O(wn) time. These sorts are seemingly simple to implement but proves to need some brain power during implementation. The source code of my implementation on these linear sorting methods can be found <a href="/downloads/2016-12-3-LinearTimeSort.java">HERE</a>. It have the basic sorting methods done, but more can be done!</p>

<p>One interesting thing about Radix sort is that it is originally invented to sort punch cards!</p>

<h2 id="references">References</h2>

<ol>
  <li><a href="http://www.cs.cmu.edu/~ab/Desktop/15-211%20Archive/res00055/lect06.pdf">http://www.cs.cmu.edu/~ab/Desktop/15-211%20Archive/res00055/lect06.pdf</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Radix_sort">https://en.wikipedia.org/wiki/Radix_sort</a></li>
</ol>


  </div>

    <div class="date">
       Written on December  3, 2016
    </div>

  
  
    
      <h3>Related post</h3>
      
        
        
      
        
          <div>
            <h5><a href="/blog/2016/12/01/Merge-Sort/">Merge Sort</a></h5>
          </div>
          
    
  
  
  <hr>
  
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'taykangsheng';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

  

</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:kangsheng@gmail.com"><i class="svg-icon email"></i></a>
<a href="https://www.facebook.com/TayKangSheng"><i class="svg-icon facebook"></i></a>

<a href="https://github.com/TayKangSheng"><i class="svg-icon github"></i></a>
<a href="https://instagram.com/kangsterchikenzster"><i class="svg-icon instagram"></i></a>



<a href="https://www.twitter.com/TayKangSheng"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  </body>
</html>
