<!DOCTYPE html>
<html>
  <head>
    <title>AVL Tree – Kang Sheng – Programmer ｜ Buddhist ｜ Traveller</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="An AVL Tree is a self balancing Binary Search Tree (BST). In the previous article on BST, we mentioned the efficiency of BST as a Data Structure if the tree is a complete tree. Another term for complete tree is a balance tree. Using AVL as a data structure, there is a guaranteed O(log n) time complexity for searching, inserting and deleting.

" />
    <meta property="og:description" content="An AVL Tree is a self balancing Binary Search Tree (BST). In the previous article on BST, we mentioned the efficiency of BST as a Data Structure if the tree is a complete tree. Another term for complete tree is a balance tree. Using AVL as a data structure, there is a guaranteed O(log n) time complexity for searching, inserting and deleting.

" />
    
    <meta name="author" content="Kang Sheng" />

    
    <meta property="og:title" content="AVL Tree" />
    <meta property="twitter:title" content="AVL Tree" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Kang Sheng - Programmer ｜ Buddhist ｜ Traveller" href="/feed.xml" />
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:300" rel="stylesheet">
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="/images/avatar.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Kang Sheng</a></h1>
            <p class="site-description">Programmer ｜ Buddhist ｜ Traveller</p>
          </div>

          <nav>
            <a href="/">Home</a>
            <a href="/blog">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>AVL Tree </h1>
  <div style="font-size: 80%; color: grey"> Categories: 
    <span>
    
      
        <a href="/blog/Programming">Programming</a> 
      
    
    </span>
  </div>


  <div class="entry">
    <p>An AVL Tree is a self balancing Binary Search Tree (BST). In the previous article on <a href="/blog/2016/11/28/Binary-Search-Trees/">BST</a>, we mentioned the efficiency of BST as a Data Structure if the tree is a complete tree. Another term for complete tree is a balance tree. Using AVL as a data structure, there is a guaranteed O(log n) time complexity for <strong>searching</strong>, <strong>inserting</strong> and <strong>deleting</strong>.</p>

<h2 id="invariant">Invariant</h2>

<p>A BST is an AVL Tree if</p>

<blockquote>
  <p><strong>balance(u) ∈ {-1, 0, +1} for every node u</strong><br />
where, balance(u) := right_height(u) - left_height(u)</p>
</blockquote>

<p>Which really means that for every node u, the heights of its left child and right child differ by at most 1.</p>

<h2 id="properties">Properties</h2>

<ol>
  <li>Due to the need to balance the tree, every node have an additional <strong>height</strong> property where it keep tracks of its height in the tree.</li>
  <li>All leaf nodes hava a height of 1, and balance of 0.</li>
  <li>AVL tree with n nodes has height of O(log n).</li>
  <li><strong>insert</strong>, <strong>delete</strong>, <strong>search</strong> can be implemented in O(log n) time.</li>
</ol>

<h2 id="rotation">Rotation</h2>

<p>The most crucial part of AVL trees is understanding the rotation mechanism. In order to maintain a balance tree while manipulating data in the tree using operations such as <strong>insert</strong>, <strong>delete</strong> etc, we rotate the tree such that the resulting tree restore its balance and maintain its BST Invariant.</p>

<p><img src="/images/2016-11-29-AVLRotation.png" alt="AVL Rotation" class="center-image" /></p>

<p>There are 2 types of basic rotation, Left Rotation and Right Rotation. Note how edges between the nodes and subtrees exchange places.</p>

<ol>
  <li>In doing left rotation, we basically turn the tree in the anti-clockwise direction.</li>
  <li>In doing right rotation, we basically turn the tree in the clockwise direction.</li>
</ol>

<p><img src="/images/2016-11-29-RightRotation.png" alt="Right Rotation" class="center-image" /></p>

<p>Below is a animated gif of the left and right rotation process.</p>

<p><img src="/images/2016-11-29-TreeRotationAnimation.gif" alt="Right Rotation" class="center-image" /></p>

<p>This is an example of how a tree is balanced after rotation. Note how the property, key of the left child is smaller than the key of the parent node and key of the right child is bigger than th ekey of the parent node, is preserved even after rotation.</p>

<p><img src="/images/2016-11-29-LeftRotationExample.png" alt="Right Rotation" class="center-image" /></p>

<h2 id="cases-for-rotation">Cases for rotation</h2>

<p>There are exactly 4 cases when we need to engage in rotation.</p>

<p><img src="/images/2016-11-29-CasesForRotation.png" alt="Cases for Rotation" class="center-image" /></p>

<p>Looking at the diagram above, in the <strong>Left Left</strong> and <strong>Right Right</strong> case, we only need to make 1 rotation in order to balance the tree. The <strong>Left Right</strong> and <strong>Right Left</strong> case requires 2 rotation, to restore the balance of the tree. From <strong>Right Left</strong> case, we do a Right Rotation at Node 5 to get to the <strong>Right Right</strong> case; and then we do a Left Rotation at Node 3 to get to a balance tree.</p>

<p>Therefore we only need to do at most 2 rotations to balance a tree.</p>

<h2 id="implementation">Implementation</h2>

<p>In this section we are going to implement the AVL tree in Java. The basic structure is exactly the same as the BST class i have implemented in the BST article and the implementation we are going to discuss in this article</p>

<h4 id="node-class">Node class</h4>

<p>As we have to account for the height of the node, we are going to add an additional height variable in the private inner node class. In the constructor, when we initalise a new node, we set the height of the node to 1. Recall that all leaf nodes have a height of 1.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AVL</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;{</span>
  <span class="c1">// Variables</span>
  <span class="o">...</span>
  <span class="c1">// Constructors</span>
  <span class="o">...</span>
  <span class="c1">// Helper Methods</span>
  <span class="o">...</span>
  <span class="c1">// Methods</span>
  <span class="o">...</span>
  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">data</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">height</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">){</span>
      <span class="n">data</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
      <span class="n">height</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
      <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">(){</span>
      <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="helper-methods">Helper Methods</h4>

<p>While we are manipulating the data, we will need a way to retrieve the height of nodes. In retrieving the height of nodes, if the node does not exist, then we return the height as 0. The height of a node, is the maximum height between the left and right child nodes + 1.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">){</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">T</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">height</span><span class="o">(</span><span class="n">T</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">height</span><span class="o">(</span><span class="n">T</span><span class="o">.</span><span class="na">right</span><span class="o">))</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Additionally, to update the height of a node, it employs the same logic.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">fix_height</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">){</span>
  <span class="n">T</span><span class="o">.</span><span class="na">height</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span> <span class="n">height</span><span class="o">(</span><span class="n">T</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">height</span><span class="o">(</span><span class="n">T</span><span class="o">.</span><span class="na">right</span><span class="o">))</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h4 id="rotation-methods">Rotation Methods</h4>

<p>Here we implement the 2 basic left and right rotation. It is highly encouraged to do some sketches on your own to grasp how the edges are updated in these rotations. These methods are fairly easy to implement as it only consist of updated a few references. However, remember to update the height of the nodes as the accuracy of the height variables are of utmost importance to balance the tree.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">rotate_left</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">){</span>
  <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Tr</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
  <span class="n">T</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">Tr</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
  <span class="n">Tr</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">T</span><span class="o">;</span>
  <span class="n">fix_height</span><span class="o">(</span><span class="n">Tr</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
  <span class="n">fix_height</span><span class="o">(</span><span class="n">Tr</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">Tr</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">rotate_right</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">){</span>
  <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Tl</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
  <span class="n">T</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">Tl</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
  <span class="n">Tl</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">T</span><span class="o">;</span>
  <span class="n">fix_height</span><span class="o">(</span><span class="n">Tl</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
  <span class="n">fix_height</span><span class="o">(</span><span class="n">Tl</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">Tl</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h4 id="balancing-methods">Balancing Methods</h4>

<p>After we have the basic rotation methods implemented, we can now implement rotation base on the four cases mentioned above, <strong>Left Right</strong>, <strong>Right Left</strong>, <strong>Left Left</strong>, <strong>Right Right</strong>. We first check whether difference in the height of the left and right subtree is bigger than 1 or -1. If the condition fulfils, then we check whether which corresponding subtrees is taller. From there we can determine which of the 4 cases is it. If the node is already balanced, then we just simply update the height of the node.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">rebalance</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">){</span>
  <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Tr</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
  <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Tl</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span> <span class="n">height</span><span class="o">(</span><span class="n">Tr</span><span class="o">)</span> <span class="o">-</span> <span class="n">height</span><span class="o">(</span><span class="n">Tl</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">){</span>
    <span class="c1">// right side heavy</span>
    <span class="k">if</span> <span class="o">(</span> <span class="n">height</span><span class="o">(</span><span class="n">Tr</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">height</span><span class="o">(</span><span class="n">Tr</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">){</span>
      <span class="c1">// right-right condition</span>
      <span class="n">T</span> <span class="o">=</span> <span class="n">rotate_left</span><span class="o">(</span><span class="n">T</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="c1">// right-left condition</span>
      <span class="n">T</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">rotate_right</span><span class="o">(</span><span class="n">Tr</span><span class="o">);</span>
      <span class="n">T</span> <span class="o">=</span> <span class="n">rotate_left</span><span class="o">(</span><span class="n">T</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span> <span class="n">height</span><span class="o">(</span><span class="n">Tr</span><span class="o">)</span> <span class="o">-</span> <span class="n">height</span><span class="o">(</span><span class="n">Tl</span><span class="o">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
    <span class="c1">// left side heavy</span>
    <span class="k">if</span> <span class="o">(</span> <span class="n">height</span><span class="o">(</span><span class="n">Tl</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">height</span><span class="o">(</span><span class="n">Tl</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">){</span>
      <span class="c1">// left-left condition</span>
      <span class="n">T</span> <span class="o">=</span> <span class="n">rotate_right</span><span class="o">(</span><span class="n">T</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="c1">// left-right condition</span>
      <span class="n">T</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">rotate_left</span><span class="o">(</span><span class="n">Tl</span><span class="o">);</span>
      <span class="n">T</span> <span class="o">=</span> <span class="n">rotate_right</span><span class="o">(</span><span class="n">T</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="c1">// Tree is already balance</span>
    <span class="n">fix_height</span><span class="o">(</span><span class="n">T</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">T</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h4 id="insert">insert</h4>

<p>The insert method is almost identical to the insert method of the BST class with the balancing of the tree after every insert.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">T</span> <span class="n">toInsert</span><span class="o">){</span>
  <span class="n">root</span> <span class="o">=</span> <span class="n">insert</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">toInsert</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">insert</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="n">T</span> <span class="n">toInsert</span><span class="o">){</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Node</span><span class="o">(</span><span class="n">toInsert</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">if</span> <span class="o">(</span> <span class="n">compare</span><span class="o">(</span> <span class="n">toInsert</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">data</span> <span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">){</span>
    <span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">insert</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">toInsert</span><span class="o">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">rebalance</span><span class="o">(</span> <span class="n">p</span> <span class="o">);</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">insert</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">toInsert</span><span class="o">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">rebalance</span><span class="o">(</span> <span class="n">p</span> <span class="o">);</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h2 id="conclusion">Conclusion</h2>

<p>AVL Tree can look easy to implement however it can be tricky to implement. I encourage you to implement it yourself from scratch because this implementation will help you gain a good understanding of recursion and updating references. Another hint is to draw it out on pen and paper before writing the code, trust me, it will help. The full source code of the AVL class i have implemented can be found <a href="/downloads/2016-11-29-AVL.java">HERE</a>. If you want to learn more, you can implement the delete method!</p>

<h2 id="references">References</h2>

<ol>
  <li><a href="http://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/avltrees.pdf">http://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/avltrees.pdf</a></li>
  <li><a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15122-s14/www/rec/19.pdf">http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15122-s14/www/rec/19.pdf</a></li>
</ol>


  </div>

    <div class="date">
       Written on November 29, 2016
    </div>

  
  
    
      <h3>Related post</h3>
      
        
          <div>
            <h5><a href="/blog/2016/12/01/Merge-Sort/">Merge Sort</a></h5>
          </div>
          
    
  
  
  <hr>
  
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'taykangsheng';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

  

</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:kangsheng@gmail.com"><i class="svg-icon email"></i></a>
<a href="https://www.facebook.com/TayKangSheng"><i class="svg-icon facebook"></i></a>

<a href="https://github.com/TayKangSheng"><i class="svg-icon github"></i></a>
<a href="https://instagram.com/kangsterchikenzster"><i class="svg-icon instagram"></i></a>



<a href="https://www.twitter.com/TayKangSheng"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  </body>
</html>
