<!DOCTYPE html>
<html>
  <head>
    <title>A Heap Data Structure – Kang Sheng – Programmer ｜ Buddhist ｜ Traveller</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: If A is a parent node of B then the key (the value) of node A is ordered with respect to the key of node B with the same ordering applying across the heap. 1

" />
    <meta property="og:description" content="In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: If A is a parent node of B then the key (the value) of node A is ordered with respect to the key of node B with the same ordering applying across the heap. 1

" />
    
    <meta name="author" content="Kang Sheng" />

    
    <meta property="og:title" content="A Heap Data Structure" />
    <meta property="twitter:title" content="A Heap Data Structure" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Kang Sheng - Programmer ｜ Buddhist ｜ Traveller" href="/feed.xml" />
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:300" rel="stylesheet">
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="/images/avatar.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Kang Sheng</a></h1>
            <p class="site-description">Programmer ｜ Buddhist ｜ Traveller</p>
          </div>

          <nav>
            <a href="/">Home</a>
            <a href="/blog">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>A Heap Data Structure </h1>
  <div style="font-size: 80%; color: grey"> Categories: 
    <span>
    
      
        <a href="/blog/Programming">Programming</a> 
      
    
    </span>
  </div>


  <div class="entry">
    <p>In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: If A is a parent node of B then the key (the value) of node A is ordered with respect to the key of node B with the same ordering applying across the heap. <a href="/downloads/2016-11-26-MaxHeap.java">1</a></p>

<p>A Heap is basically an implementation of a <a href="https://en.wikipedia.org/wiki/Priority_queue">priority queue</a>, therefore before we jump into how does a heap work and what is it for, we should first understand what is a <strong>priority queue</strong>.</p>

<h2 id="what-is-a-priority-queue">What is a Priority Queue?</h2>

<p>Priority Queue is an Abstract Data Type (ADT) implementing a set S of elements (each associated with a key) supporting the following operations.<br />
k(x) = key of element x</p>

<ol>
  <li>max(S): returns element from S with largest key</li>
  <li>insert(S,x): insert element x into set S</li>
  <li>extract_max(S): return element from S with largest key and remove it from S</li>
  <li>increase_key(S,x,k’): increase the value of element x’s key k(x) to new value k’ (assumed to be larger than the current value)</li>
</ol>

<h4 id="example-of-a-priority-queue">Example of a priority queue</h4>

<p>A basic priority queue can be implemented using a array to store the elements. Note that the definition above clearly states that it is a set, which means that there can be no duplicate keys in the same set. Therefore in the case of a array, we do not allow for duplicate elements. Of course changes can be made at your own discretion if allowing for duplicate is something that will work for you.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PriorityQueue</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">elements</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
	
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">Max</span><span class="o">(){</span>
    <span class="kt">int</span> <span class="n">largest_element</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">elements</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">elements</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">largest_element</span> <span class="o">){</span>
        <span class="n">largest_element</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">largest_element</span><span class="o">;</span>
  <span class="o">}</span>
	
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">elements</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">x</span><span class="o">)){</span>
      <span class="n">elements</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
	
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">extract_max</span><span class="o">(){</span>
    <span class="kt">int</span> <span class="n">max_element</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">Max</span><span class="o">();</span>
    <span class="n">elements</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">max_element</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">max_element</span><span class="o">;</span>
  <span class="o">}</span>
	
  <span class="kd">public</span>  <span class="kt">boolean</span> <span class="nf">increase_key</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">){</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">elements</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">elements</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span><span class="o">){</span>
        <span class="n">elements</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">elements</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)+</span><span class="n">value</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="heap-and-how-it-looks-like">Heap and how it looks like.</h2>

<p>As mentioned before, a heap is an implementation of a priority queue. It is an array visualised as a nearly complete binary tree. Navigating on the binary tree is actually just moving along an array of elements.</p>

<p><img src="/images/2016-11-26-1.png" alt="Heap" class="center-image" /></p>

<p>There are 2 main types of Heap, the Max Heap and the Min Heap. In a Max Heap, the keys(the value) of parent nodes are always greater or equals than those of the children nodes and the largest key is the root node. In a Min Heap, its the other way around, where the parent nodes are always smaller or equals than those of the children nodes, and the smallest key is the root node.</p>

<p>How do we visualise an array as a tree?</p>

<ol>
  <li>The root of the tree corresponds to the <strong>index = 1</strong> of the array.</li>
  <li>The index of the parent node of node at index i is (i/2). e.g. parent(5)=2.</li>
  <li>The index of the left child of node at index i is 2(i). left(4)=8.</li>
  <li>The index of the right child of node at index i is 2(i)+1. right(4)=9.</li>
  <li>NOTE: The first index must be 1, if not the mathematical rules to find the children nodes will not work.</li>
</ol>

<p>Some basic properties of a Heap.</p>

<ol>
  <li>There is no need for pointers as the the parent and child nodes can be found using simple mathematical operations.</li>
  <li>The height of a binary Heap is O(log n), which means at most log n. Therefore any path from root to the leaf node is at most log n steps.</li>
</ol>

<p>Operations with Heap (max).</p>

<ol>
  <li>build_max_heap: Produce a max-heap from an unordered array in O(n).</li>
  <li>max_heapify: correct a single violation of the heap property occuring at the root of a subtree in O(log n).</li>
  <li>insert: Insert a node into the tree and re-order if needed to not violate the heap property.</li>
  <li>extract_max: Extract the root node and re-order the tree such that it does not violate the heap property.</li>
  <li>heapsort: sort an array of size n in O(n log n) using heaps.</li>
</ol>

<h4 id="maxheapify">max_heapify</h4>

<p>The point of this operation is to correct a violation of the heap property occuring at the root of a subtree. If either key of the left-child or the right-child of this root node is bigger than the key of this root node, the property of the Max Heap is violated. Therefore we want to solve this violation by trickling this key down the tree until there is no more violation of the Heap property. Below is a graphical representation of what we want to achieve in this operation.</p>

<p><img src="/images/2016-11-26-2.png" alt="max_heaify" class="center-image" /></p>

<p>Therefore, there are 2 main steps in this operations:</p>

<ol>
  <li>Find the index of the largest key among A[i], A[left(i)] and A[right[i]]</li>
  <li>If this index is different than i, exchange A[i] with largest key; then recurse on subtree with the root node of the recursed subtree as the previous A[i] key. This is to ensure that after the key is trickled down, we want to check recursively until there is no more violations of the Heap property.</li>
</ol>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">max_heapify</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
  <span class="kt">int</span> <span class="n">left_index</span> <span class="o">=</span> <span class="o">(</span><span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">right_index</span> <span class="o">=</span> <span class="o">(</span><span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">)+</span><span class="mi">1</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">largest_index</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">left_index</span> <span class="o">&lt;=</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> 
  		<span class="o">&amp;&amp;</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">left_index</span><span class="o">)&gt;</span><span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">){</span>
    <span class="n">largest_index</span> <span class="o">=</span> <span class="n">left_index</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">largest_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">right_index</span> <span class="o">&lt;=</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> 
  		<span class="o">&amp;&amp;</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">right_index</span><span class="o">)&gt;</span><span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">largest_index</span><span class="o">)</span> <span class="o">){</span>
    <span class="n">largest_index</span> <span class="o">=</span> <span class="n">right_index</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">largest_index</span> <span class="o">!=</span> <span class="n">index</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">largest_index</span><span class="o">);</span>
    <span class="n">heap</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">largest_index</span><span class="o">,</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">));</span>
    <span class="n">heap</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">index</span><span class="o">,</span> <span class="n">temp</span><span class="o">);</span>
    <span class="n">max_heapify</span><span class="o">(</span><span class="n">largest_index</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h4 id="buildmaxheap">build_max_heap</h4>

<p>If given an array of keys, we want to convert this array into a Max Heap. This operation can be executed using the <strong>max_heapify</strong> operation we have implemented above. One observation we can make is that while arranging the keys in the Heap, violation can only occur at nodes 1..[n/2] as the nodes [n/2]+1..n are leaf nodes.</p>

<p>Therefore this operation only consist of 1 step:</p>

<ol>
  <li>Initialise all elements of the given array into an unsorted array.</li>
  <li>Loop backwards from node n/2 to the root node 1, and do max_heapify.</li>
</ol>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">build_max_heap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">){</span>
  <span class="n">heap</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// This is to ensure that the index of the first element is 1;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="n">heap</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
  <span class="o">}</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()/</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
    <span class="n">max_heapify</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="n">heap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h4 id="insert">insert</h4>

<p>How do we insert an node in a heap yet not violating any heap property? The general idea is to insert the node at the end of the array, then recursively check whether the key of the parent node is bigger or smaller than the new node. If yes, switch the position of the parent node and the new node, then check the key of the new parent node of the new node. So we slowly trickle the node from the bottom up until it finds a place where it does not violate the Max_Heap property.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">){</span>
  <span class="n">heap</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">current_index</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">current_index</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">parent_index</span> <span class="o">=</span> <span class="n">current_index</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">parent_index</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">current_index</span><span class="o">)</span> <span class="o">){</span>
      <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">parent_index</span><span class="o">);</span>
      <span class="n">heap</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">parent_index</span><span class="o">,</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">current_index</span><span class="o">));</span>
      <span class="n">heap</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">current_index</span><span class="o">,</span> <span class="n">temp</span><span class="o">);</span>
      <span class="n">current_index</span> <span class="o">=</span> <span class="n">parent_index</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h4 id="extractmax">extract_max</h4>

<p>Now that we have implemented the <strong>max_heapify</strong> operation, we can use the <strong>max_heapify</strong> operation to extract the node with the largest key in the Heap. The idea is simple. First switch the position of the root node and the last node in the array. Now remove the original root node, and use <strong>max_heapify</strong> on the new root node. As the new root node is originally a leaf node, it will now trickle down again to the base while re-arranging the Heap into a new position which does not violate the Max Heap property.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">extract_max</span><span class="o">(){</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">){</span>
    <span class="k">return</span> <span class="n">heap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="c1">// Note that the first element is a place holder (null). </span>
    <span class="c1">// This is to ensure the first element of the heap is at index 1.</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">last_node</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">heap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">heap</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">last_node</span><span class="o">);</span>
    <span class="n">max_heapify</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="heapsort">heapsort</h4>

<p><strong>Heapsort</strong> is the last operation that we are going to discuss in this article. As mentioned above <strong>Heapsort</strong> is a sorting algorithm that sorts an array of size n in O(n log n) using Heaps.</p>

<p>Now that we have gone through the various operations of a Heap, implementing Heap sort is now trivial. We can simple call the <strong>extract_max</strong> operation n times to produce a sorted array.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">heapsort</span><span class="o">(){</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">sorted_array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">];</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">sorted_array</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="n">sorted_array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">extract_max</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">sorted_array</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h2 id="time-complexity">Time Complexity</h2>

<p>Now that we have gone through so much about how to implement a Heap data type, how efficient is actually the Heap is manipulating data.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th> </th>
      <th style="text-align: left"><strong>Time Complexity</strong></th>
      <th> </th>
      <th style="text-align: left"><strong>Operation</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">a)</td>
      <td> </td>
      <td style="text-align: left">O(n)</td>
      <td> </td>
      <td style="text-align: left">build_max_heap</td>
    </tr>
    <tr>
      <td style="text-align: left">b)</td>
      <td> </td>
      <td style="text-align: left">O(log n)</td>
      <td> </td>
      <td style="text-align: left">max_heapify</td>
    </tr>
    <tr>
      <td style="text-align: left">c)</td>
      <td> </td>
      <td style="text-align: left">O(log n)</td>
      <td> </td>
      <td style="text-align: left">insert, extract_max, increase_key</td>
    </tr>
    <tr>
      <td style="text-align: left">d)</td>
      <td> </td>
      <td style="text-align: left">O(n log n)</td>
      <td> </td>
      <td style="text-align: left">heapsort</td>
    </tr>
  </tbody>
</table>

<p>Keep in mind that the height of the <strong>Heap</strong> is at most log n, therefore searching for a key is at most log n steps. As with operations such as <strong>max_heapify</strong>, if the node that needs to be checked is right at the top, the worse case senario is to move the node all the way node to the bottom which is at most log n steps.</p>

<h2 id="conclusion">Conclusion</h2>

<p><strong>Heaps</strong> can be a simple and effective data structure. It might not be the fastest data structure to access your data, but it is simple to implement and works fairly effectively. The codes that i have shown above can be downloaded <a href="/downloads/2016-11-26-MaxHeap.java">HERE</a>! If you have found that the code is wrong in anyway, feel free to drop me an email and we can discuss how to make the code better. It is a never ending learning process as a programmer and I am too forever a student of the Computer Science domain.</p>

<h1 id="references">References</h1>
<ol>
  <li>https://en.wikipedia.org/wiki/Heap_(data_structure)</li>
  <li>Singapore University of Technology and Design, Information Systems Technology &amp; Design, 50.004 Intro to Algorithms Slides</li>
</ol>


  </div>

    <div class="date">
       Written on November 26, 2016
    </div>

  
  
    
      <h3>Related post</h3>
      
        
          <div>
            <h5><a href="/blog/2016/11/26/Difference-between-an-Array-and-List/">Difference between an Array and List?</a></h5>
          </div>
          
    
  
  
  <hr>
  
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'taykangsheng';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

  

</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:kangsheng@gmail.com"><i class="svg-icon email"></i></a>
<a href="https://www.facebook.com/TayKangSheng"><i class="svg-icon facebook"></i></a>

<a href="https://github.com/TayKangSheng"><i class="svg-icon github"></i></a>
<a href="https://instagram.com/kangsterchikenzster"><i class="svg-icon instagram"></i></a>



<a href="https://www.twitter.com/TayKangSheng"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  </body>
</html>
